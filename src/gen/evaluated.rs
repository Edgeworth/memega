use crate::cfg::{Cfg, Crossover, Duplicates, Mutation, Selection, Survival};
use crate::gen::species::NO_SPECIES;
use crate::gen::unevaluated::UnevaluatedGen;
use crate::gen::Params;
use crate::ops::mutation::{mutate_lognorm, mutate_normal, mutate_rate};
use crate::ops::sampling::{multi_rws, rws, sus};
use crate::runner::RandGenome;
use crate::{Evaluator, Genome, State};
use derive_more::Display;
use eyre::{eyre, Result};

#[derive(Display, Clone, PartialOrd, PartialEq)]
#[display(
    fmt = "base fitness {:.2}, selection fitness {:.2}",
    base_fitness,
    selection_fitness
)]
pub struct Member<T: Genome> {
    pub state: State<T>,
    pub base_fitness: f64, // Original fitness, generated by Evaluator fitness function.
    pub selection_fitness: f64, // Potentially adjusted fitness, for selection.
}

#[derive(Display, Clone, PartialOrd, PartialEq)]
#[display(fmt = "pop: {}, best: {}", "mems.len()", "self.nth(0)")]
pub struct EvaluatedGen<T: Genome> {
    mems: Vec<Member<T>>,
}

impl<T: Genome> EvaluatedGen<T> {
    pub fn new(mut mems: Vec<Member<T>>) -> Self {
        // Sort by base fitness. Selection should happen using selection
        // fitness. Generate survivors using base fitness, to make sure we keep
        // the top individuals.
        mems.sort_unstable_by(|a, b| b.base_fitness.partial_cmp(&a.base_fitness).unwrap());
        Self { mems }
    }

    pub fn size(&self) -> usize {
        self.mems.len()
    }

    pub fn nth(&self, n: usize) -> &Member<T> {
        &self.mems[n]
    }

    pub fn species_mems(&self, n: u64) -> Vec<Member<T>> {
        self.mems
            .iter()
            .filter(|v| v.state.species == n)
            .cloned()
            .collect()
    }

    pub fn mean_base_fitness(&self) -> f64 {
        self.mems.iter().map(|v| v.base_fitness).sum::<f64>() / self.mems.len() as f64
    }

    pub fn num_dup(&self) -> usize {
        let mut mems_copy = self
            .mems
            .iter()
            .map(|v| &v.state.genome)
            .cloned()
            .collect::<Vec<_>>();
        mems_copy.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());
        mems_copy.dedup();
        self.mems.len() - mems_copy.len()
    }

    // Get list of species.
    pub fn species(&self) -> Vec<u64> {
        // Relies on species index assignment to be contigous from zero.
        let mut species: Vec<_> = self.mems.iter().map(|mem| mem.state.species).collect();
        species.sort_unstable();
        species.dedup();
        species
    }

    fn take(mems: &[Member<T>], num: usize) -> Vec<State<T>> {
        mems.iter().map(|v| &v.state).cloned().take(num).collect()
    }

    fn survivors(&self, survival: Survival, cfg: &Cfg) -> Vec<State<T>> {
        match survival {
            Survival::TopProportion(prop) => {
                // Ceiling so we don't miss keeping things for small sizes.
                // Use the target population size rather than the size of the
                // current generation so small generations don't have a smaller
                // number of survivors selected from them. This is useful for
                // with a small number of individuals.
                let num = (cfg.pop_size as f64 * prop).ceil() as usize;
                Self::take(&self.mems, num)
            }
            Survival::SpeciesTopProportion(prop) => {
                let mut survivors = Vec::new();
                let species = self.species();
                let num = (cfg.pop_size as f64 * prop / species.len() as f64).ceil() as usize;
                for id in species {
                    survivors.extend(self.species_mems(id).into_iter().take(num).map(|v| v.state));
                }
                survivors
            }
        }
    }

    fn selection(&self, selection: Selection) -> [State<T>; 2] {
        let fitnesses = self
            .mems
            .iter()
            .map(|v| v.selection_fitness)
            .collect::<Vec<_>>();
        let idxs = match selection {
            Selection::Sus => sus(&fitnesses, 2),
            Selection::Roulette => multi_rws(&fitnesses, 2),
        };
        [
            self.mems[idxs[0]].state.clone(),
            self.mems[idxs[1]].state.clone(),
        ]
    }

    fn check_weights(weights: &[f64], l: usize) -> Result<()> {
        if weights.len() != l {
            return Err(eyre!(
                "number of fixed weights {} doesn't match {}",
                weights.len(),
                l
            ));
        }
        for &v in weights.iter() {
            if v < 0.0 {
                return Err(eyre!("weights must all be non-negative: {}", v));
            }
        }
        Ok(())
    }

    fn crossover<E: Evaluator<Genome = T>>(
        &self,
        crossover: &Crossover,
        eval: &E,
        s1: &mut State<T>,
        s2: &mut State<T>,
    ) -> Result<()> {
        match crossover {
            Crossover::Fixed(rates) => {
                s1.params.crossover = rates.clone();
                s2.params.crossover = rates.clone();
            }
            Crossover::Adaptive => {
                let lrate = 1.0 / (self.size() as f64).sqrt();
                mutate_rate(&mut s1.params.crossover, 1.0, |v| {
                    mutate_normal(v, lrate).max(0.0)
                });
                mutate_rate(&mut s2.params.crossover, 1.0, |v| {
                    mutate_normal(v, lrate).max(0.0)
                });
            }
        };
        Self::check_weights(&s1.params.crossover, E::NUM_CROSSOVER)?;
        Self::check_weights(&s2.params.crossover, E::NUM_CROSSOVER)?;
        let idx = rws(&s1.params.crossover).unwrap();
        eval.crossover(&mut s1.genome, &mut s2.genome, idx);
        Ok(())
    }

    fn mutation<E: Evaluator<Genome = T>>(
        &self,
        mutation: &Mutation,
        eval: &E,
        s: &mut State<T>,
    ) -> Result<()> {
        match mutation {
            Mutation::Fixed(rates) => {
                s.params.mutation = rates.clone();
            }
            Mutation::Adaptive => {
                // Apply every mutation with the given rate.
                // c' = c * e^(learning rate * N(0, 1))
                let lrate = 1.0 / (self.size() as f64).sqrt();
                mutate_rate(&mut s.params.mutation, 1.0, |v| {
                    mutate_lognorm(v, lrate).clamp(0.0, 1.0)
                });
            }
        };
        Self::check_weights(&s.params.mutation, E::NUM_MUTATION)?;
        for (idx, &rate) in s.params.mutation.iter().enumerate() {
            eval.mutate(&mut s.genome, rate, idx);
        }
        Ok(())
    }


    pub fn next_gen<E: Evaluator<Genome = T>>(
        &self,
        mut genfn: Option<&mut (dyn RandGenome<T> + '_)>,
        cfg: &Cfg,
        eval: &E,
    ) -> Result<UnevaluatedGen<T>> {
        // Pick survivors:
        let mut new_states = self.survivors(cfg.survival, cfg);
        // Min here to avoid underflow - can happen if we produce too many parents.
        new_states.reserve(cfg.pop_size);

        // If DisallowDuplicates on, try up to NUM_TRIES times
        // to fill the population up.
        const NUM_TRIES: usize = 3;
        for _ in 0..NUM_TRIES {
            if let Some(genfn) = &mut genfn {
                // Use custom generation function, e.g. for stagnation.
                while new_states.len() < cfg.pop_size {
                    new_states.push(State {
                        genome: (*genfn)(),
                        params: Params::new::<E>(cfg),
                        species: NO_SPECIES,
                    });
                }
            } else {
                // Reproduce.
                while new_states.len() < cfg.pop_size {
                    let [mut s1, mut s2] = self.selection(cfg.selection);
                    self.crossover(&cfg.crossover, eval, &mut s1, &mut s2)
                        .unwrap();
                    self.mutation(&cfg.mutation, eval, &mut s1).unwrap();
                    self.mutation(&cfg.mutation, eval, &mut s2).unwrap();
                    new_states.push(s1);
                    new_states.push(s2);
                }
            }

            // Remove duplicates if we need to.
            if cfg.duplicates == Duplicates::DisallowDuplicates {
                new_states.sort_unstable_by(|a, b| a.genome.partial_cmp(&b.genome).unwrap());
                new_states.dedup_by(|a, b| a.genome.eq(&b.genome));
            }
        }
        Ok(UnevaluatedGen::new(new_states))
    }
}
